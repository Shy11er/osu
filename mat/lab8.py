# Описание задачи:
# Программа выполняет численное интегрирование функции f(x) = 4 * e^(x^2)
# на заданном интервале с использованием различных методов: левых, правых, средних прямоугольников, трапеций и Симпсона.
# Программа также вычисляет теоретическое число разбиений для достижения заданной точности epsilon
# и сравнивает результаты различных методов.

import math

# Функция для оценки максимума производной на интервале
# derivative: переданная функция производной
# a: левая граница интервала
# b: правая граница интервала
# steps: количество шагов для итераций
# Возвращает максимальное значение производной на интервале
def max_derivative(derivative, a, b, steps=1000):
    max_value = float('-inf')  # Инициализируем начальное максимальное значение как отрицательная бесконечность
    step = (b - a) / steps  # Вычисляем шаг итерации
    x = a  # Начинаем с левой границы
    while x <= b:
        value = abs(derivative(x))  # Берем модуль значения производной в точке x
        if value > max_value:  # Если текущее значение больше текущего максимума
            max_value = value  # Обновляем максимум
        x += step  # Переходим к следующей точке
    return max_value  # Возвращаем найденное максимальное значение

# Метод левых прямоугольников
# f: интегрируемая функция
# a: левая граница интегрирования
# b: правая граница интегрирования
# epsilon: заданная точность
# Возвращает значение интеграла, вычисленного методом левых прямоугольников
def left_rectangle(f, a, b, epsilon):
    n = 1  # Начальное число разбиений
    prev, current = 0, 0  # Инициализация предыдущего и текущего значений интеграла
    while True:
        prev = current  # Сохраняем текущее значение
        current = 0  # Обнуляем текущее значение интеграла
        h = (b - a) / n  # Шаг разбиения
        for i in range(n):
            current += f(a + i * h) * h  # Добавляем площадь прямоугольника
        if abs(current - prev) <= epsilon:  # Проверяем условие остановки
            break
        n *= 2  # Удваиваем число разбиений
    print(f"Левые прямоугольники - практическое число разбиений: {n // 2}")
    return current

# Метод правых прямоугольников
# f: интегрируемая функция
# a: левая граница интегрирования
# b: правая граница интегрирования
# epsilon: заданная точность
# Возвращает значение интеграла, вычисленного методом правых прямоугольников
def right_rectangle(f, a, b, epsilon):
    n = 1  # Начальное число разбиений
    prev, current = 0, 0  # Инициализация предыдущего и текущего значений интеграла
    while True:
        prev = current  # Сохраняем текущее значение
        current = 0  # Обнуляем текущее значение интеграла
        h = (b - a) / n  # Шаг разбиения
        for i in range(1, n + 1):
            current += f(a + i * h) * h  # Добавляем площадь прямоугольника
        if abs(current - prev) <= epsilon:  # Проверяем условие остановки
            break
        n *= 2  # Удваиваем число разбиений
    print(f"Правые прямоугольники - практическое число разбиений: {n // 2}")
    return current

# Метод средних прямоугольников
# f: интегрируемая функция
# a: левая граница интегрирования
# b: правая граница интегрирования
# epsilon: заданная точность
# Возвращает значение интеграла, вычисленного методом средних прямоугольников
def mid_rectangle(f, a, b, epsilon):
    n = 1  # Начальное число разбиений
    prev, current = 0, 0  # Инициализация предыдущего и текущего значений интеграла
    while True:
        prev = current  # Сохраняем текущее значение
        current = 0  # Обнуляем текущее значение интеграла
        h = (b - a) / n  # Шаг разбиения
        for i in range(n):
            current += f(a + (i + 0.5) * h) * h  # Добавляем площадь прямоугольника с учетом середины отрезка
        if abs(current - prev) <= epsilon:  # Проверяем условие остановки
            break
        n *= 2  # Удваиваем число разбиений
    print(f"Средние прямоугольники - практическое число разбиений: {n // 2}")
    return current

# Метод трапеций
# f: интегрируемая функция
# a: левая граница интегрирования
# b: правая граница интегрирования
# epsilon: заданная точность
# Возвращает значение интеграла, вычисленного методом трапеций
def trapezoidal(f, a, b, epsilon):
    n = 1  # Начальное число разбиений
    prev, current = 0, 0  # Инициализация предыдущего и текущего значений интеграла
    while True:
        prev = current  # Сохраняем текущее значение
        current = 0  # Обнуляем текущее значение интеграла
        h = (b - a) / n  # Шаг разбиения
        for i in range(n):
            current += (f(a + i * h) + f(a + (i + 1) * h)) * h / 2  # Добавляем площадь трапеции
        if abs(current - prev) <= epsilon:  # Проверяем условие остановки
            break
        n *= 2  # Удваиваем число разбиений
    print(f"Трапеции - практическое число разбиений: {n // 2}")
    return current

# Метод Симпсона
# f: интегрируемая функция
# a: левая граница интегрирования
# b: правая граница интегрирования
# epsilon: заданная точность
# Возвращает значение интеграла, вычисленного методом Симпсона
def simpson(f, a, b, epsilon):
    n = 2  # Начальное число разбиений (должно быть четным)
    prev, current = 0, 0  # Инициализация предыдущего и текущего значений интеграла
    while True:
        prev = current  # Сохраняем текущее значение
        current = 0  # Обнуляем текущее значение интеграла
        h = (b - a) / n  # Шаг разбиения
        for i in range(n):
            x0 = a + i * h  # Левая точка отрезка
            x1 = x0 + h  # Правая точка отрезка
            current += (f(x0) + 4 * f((x0 + x1) / 2) + f(x1)) * h / 6  # Добавляем площадь под параболой
        if abs(current - prev) <= epsilon:  # Проверяем условие остановки
            break
        n *= 2  # Удваиваем число разбиений
    print(f"Симпсон - практическое число разбиений: {n // 2}")
    return current

# Функции для вычисления теоретического числа разбиений для каждого метода
# Теоретические оценки зависят от второй или четвертой производных функции и заданной точности

def theoretical_rectangles(a, b, epsilon, second_derivative):
    max_m = max_derivative(second_derivative, a, b)  # Максимум второй производной
    return math.ceil(math.sqrt((max_m * (b - a) ** 3) / (12 * epsilon)))  # Формула для оценки разбиений

def theoretical_mid_rectangles(a, b, epsilon, second_derivative):
    max_m = max_derivative(second_derivative, a, b)  # Максимум второй производной
    return math.ceil(math.sqrt((max_m * (b - a) ** 3) / (24 * epsilon)))  # Формула для оценки разбиений

def theoretical_trapezoidal(a, b, epsilon, second_derivative):
    max_m = max_derivative(second_derivative, a, b)  # Максимум второй производной
    return math.ceil(math.sqrt((max_m * (b - a) ** 3) / (12 * epsilon)))  # Формула для оценки разбиений

def theoretical_simpson(a, b, epsilon, fourth_derivative):
    max_m = max_derivative(fourth_derivative, a, b)  # Максимум четвертой производной
    return math.ceil(((max_m * (b - a) ** 5) / (180 * epsilon)) ** 0.25)  # Формула для оценки разбиений

# Основная функция программы
def main():
    f = lambda x: 4 * math.exp(x ** 2)  # Исходная функция f(x)
    second_derivative = lambda x: 16 * math.exp(x ** 2) * (1 + 2 * x ** 2)  # Вторая производная f(x)
    fourth_derivative = lambda x: 16 * math.exp(x ** 2) * (12 * x ** 4 + 48 * x ** 2 + 12)  # Четвертая производная f(x)

    a, b = -1, 0  # Интервал интегрирования
    epsilon = 1e-6  # Заданная точность

    # Вывод теоретического числа разбиений
    print("Теоретическое число разбиений:")
    print("Левые и правые прямоугольники:", theoretical_rectangles(a, b, epsilon, second_derivative))
    print("Средние прямоугольники:", theoretical_mid_rectangles(a, b, epsilon, second_derivative))
    print("Трапеции:", theoretical_trapezoidal(a, b, epsilon, second_derivative))
    print("Симпсон:", theoretical_simpson(a, b, epsilon, fourth_derivative))

    # Практическое вычисление интегралов
    print("\nПрактическое вычисление интегралов:")
    print("Метод левых прямоугольников:", left_rectangle(f, a, b, epsilon))
    print("Метод правых прямоугольников:", right_rectangle(f, a, b, epsilon))
    print("Метод средних прямоугольников:", mid_rectangle(f, a, b, epsilon))
    print("Метод трапеций:", trapezoidal(f, a, b, epsilon))
    print("Метод Симпсона:", simpson(f, a, b, epsilon))

if __name__ == "__main__":
    main()

# Методы прямоугольников:

#     Метод левых прямоугольников:
#         В этом методе площадь каждого прямоугольника рассчитывается на основе значения функции в левой границе подотрезка.
#         Формула: I≈h⋅∑i=0n−1f(xi)I≈h⋅∑i=0n−1​f(xi​), где xi=a+i⋅hxi​=a+i⋅h, hh — шаг разбиения.
#         Недостаток: Метод может быть неточным, если функция сильно изменяется на каждом интервале, так как учитывается только значение на левой границе.

#     Метод правых прямоугольников:
#         Здесь используется значение функции в правой границе подотрезка для вычисления площади.
#         Формула: I≈h⋅∑i=1nf(xi)I≈h⋅∑i=1n​f(xi​), где xi=a+i⋅hxi​=a+i⋅h.
#         Недостаток аналогичен методу левых прямоугольников, но сдвиг оценки в другую сторону.

#     Метод средних прямоугольников:
#         Для каждого подотрезка площадь прямоугольника вычисляется на основе значения функции в середине интервала.
#         Формула: I≈h⋅∑i=0n−1f(xi+0.5)I≈h⋅∑i=0n−1​f(xi+0.5​), где xi+0.5=a+(i+0.5)⋅hxi+0.5​=a+(i+0.5)⋅h.
#         Преимущество: Метод часто более точен, чем методы левых и правых прямоугольников, так как учитывается среднее значение функции.

# Метод трапеций:

#     Здесь каждый подотрезок аппроксимируется трапецией, площадь которой определяется средней высотой на концах подотрезка.
#     Формула: I \approx \frac{h}{2} \cdot \sum_{i=0}^{n-1} \left( f(x_i) + f(x_{i+1}) \\right).
#     Преимущество: Этот метод более точен, чем методы прямоугольников, так как использует линейную аппроксимацию функции на каждом подотрезке.

# Метод Симпсона:

#     Основан на параболической аппроксимации функции: для каждого подотрезка используется парабола, проходящая через три точки.
#     Формула: I \approx \frac{h}{6} \cdot \sum_{i=0}^{n-1} \left( f(x_i) + 4f(x_{mid}) + f(x_{i+1}) \\right), где xmidxmid​ — середина интервала.
#     Преимущество: Метод значительно точнее, особенно если функция плавная, так как учитывается изменение функции по квадратичному закону.

